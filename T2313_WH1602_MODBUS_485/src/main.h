#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>

/**
	конфигурация фьюзов: https://eleccelerator.com/fusecalc/fusecalc.php?chip=attiny2313&LOW=E4&HIGH=9F&EXTENDED=FF&LOCKBIT=FF

 для F=8MГц (внешний кварц) старт 14СК + 64мс
*/
#define F_CPU 8000000UL

#define		SetBit(reg, bit)			reg |= (1<<bit)           
#define		ClrBit(reg, bit)			reg &= (~(1<<bit))
#define		InvBit(reg, bit)			reg ^= (1<<bit)
#define		BitIsSet(reg, bit)			((reg & (1<<bit)) != 0)
#define		BitIsClr(reg, bit)		((reg & (1<<bit)) == 0)

//===============================================================================
// BOARD
//===============================================================================
// #define PortDATA		PORTB	//порт на индикатор WH1602 данные
// #define PinDATA			PINB	//

// #define PortCTRL		PORTD	//порт управления
#define PinRx			0		//вывод Rx
#define PinTx			1		//вывод Tx
#define PinTxRx			2		//вывод управления прием/передача RS485 (0-прием; 1-передача)
#define PinWH_RW		3		//R/W (1-запись в дисплей, 0-чтение из дисплея)
#define PinWH_RS		4		//RS (1-данные, 0-команда)
#define PinWH_KLight	5		//Управление подсветкой
#define PinWH_E			6		//E (тактирование - по заднему фронту => с 1 в 0)

//===============================================================================
volatile uint8_t FLAGS1 = 0;
#define FL1_BLINK			0		//
#define FL1_0_OVER			1		//переполнение счетчика 0
#define FL1_TX				4		//передача байта по RS485 завершена
// //===============================================================================
#define LCD_CMD				1		//константа команды
#define LCD_DATA			0		//константа данных
//===============================================================================
volatile uint8_t MY_ADDR = 201;		//адрес на который отзывается котроллер по шине RS485
#define RX_BUFFER_SIZE		40		//размер приемного буфера в байтах
volatile uint8_t RX_BUFFER[RX_BUFFER_SIZE] = {0};	//приемный буфер RS232/485
volatile uint8_t RX_cnt = 0;		//счетчик принимаемых байт по RS232/485
#define TX_BUFFER_SIZE		40		//размер передаваемого буфера в байтах
volatile uint8_t TX_BUFFER[TX_BUFFER_SIZE] = {0};	//передаваемый буфер RS232/485
volatile uint8_t TX_cnt = 0;		//счетчик передаваемых байт по RS232/485
volatile uint8_t TX_size = 0;		//кол-во передаваемых байт по RS232/485
//===============================================================================
void init(void);
void LCD_init(void);
void LCD_send(uint8_t rs, uint8_t data);
void AnalizBUFFER(void);
uint16_t CalkCRC16(uint8_t* buffer, uint8_t cnt);
void StartTX_RS232(uint8_t tx);
//===============================================================================
/**
Схема осуществляет индикацию данных на индикаторе WH1602.
На входе преобразователь RS485 - RS232.
Формат входящей посылки (in HEX) пример:
	C9	адрес МК(мой) 8 бит = MY_ADDR
	10	команда - запись группы регистров 8 бит
	00	адрес строки ст.разряд (у нас будет всегда 00)
	01	адрес строки мл.разряд (у нас будет 0 или 1 - индекс строки)
	00	адрес позиции первого символа ст.разряд (у нас будет всегда 00)
	08	адрес позиции первого символа мл.разряд (у нас будет от 0 до 32)2 строки по 16 символов
	10	число байт данных (у нас будет не более 32)
	ХХ		байты символов в ASCII
	...
	AD	CRC ст.байт
	31	CRC мл.байт

Команда очистки дисплея
	C9	адрес МК(мой) 8 бит = MY_ADDR
	0A	команда - очистить дисплей
	D7	CRC ст.байт
	E7	CRC мл.байт

Ответ:
	C9	адрес МК(мой) 8 бит
	10	команда - запись группы регистров 8 бит
	00	код ответа - 00 = все хорошо или код ошибки
	XX	CRC ст.байт
	XX	CRC мл.байт
*/
























